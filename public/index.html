<!DOCTYPE html>
<html>
<head>
  <title>Audio Recorder</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="shortcut icon" href="#">
  <link rel="stylesheet" type="text/css" href="./styles/styles.css">
</head>
<body style="display: block;  background: aliceblue;height: fit-content;min-height: 100vh;">
  <section style="min-width: 175px;max-width: 175px;border-right: solid;display: flex;flex-direction: column; margin: -10px -10px -8px; padding: 8px;background-color: #302f2f;position:fixed;height: -webkit-fill-available;">
    <button id="voicePageButton">Voice</button>
    <button id="chatPageButton">Text</button>
    <button id="settingsButton">Settings</button>
    <section id="settings"style="display: none; flex-direction: column;">
    <div>
      <label for="voices" style="color:white">Choose A Voice:</label> 
      <br>
      <select name="voices" id="voices"> 
          <option value="discovery">Butler</option> 
          <option value="dave">Dave</option> 
          <option value="hannah">Hannah</option> 
          <option value="sam">Sam</option> 
          <option value="oldMan">Old Rich Man</option> 
      </select>
    </div>
    <label style="color:white"> Token Amount:<br><input type="number" min="25" max="300" class="tokenAmount" value="100"/></label>
    <label style="color:white">Chat Prompt:<input type="text" class="chatPrompt"/></label>
    <button id="sendData">Send data</button>
  </section>
  </nav>
</section>
  <section id="voicePage" style="padding-left: 175px;;">
    <section class="alignButtons">
      <div class="flexColumn">
        <button id="recordButton" class="button">Hold To Record</button>
        <!-- <button id="stop" class="button" disabled>Stop</button> -->
      </div>
      <div style="align-self: center;display: flex;align-items: center;flex-direction: column-reverse;">
        <button id="playAI" class="aiButton1" disabled>
          <span class="aiButton1__text">Play AI Response</span></button>
      </div>
    </section>
    <audio id="player"></audio>
    <audio id="aiResponsePlayer"></audio>
</section>
<section id="chatPage" style="width: -webkit-fill-available;display: none; padding-left: 250px;">
  <div id="chatbox" style="display: flex;width: 75%;padding: 0 5.5% 125px 5%;flex-direction: column;">
    <p id="chatContent" ></p>
  </div>
  <div class="wrapper">
    <textarea id="userInput" placeholder="Send a message" required></textarea>
    <button id="sendText" style="width: 40px;">></button>
  </div>
</section>



  <script>
    // require('dotenv').config();
    const audio = document.querySelector('#aiResponsePlayer');
    const chatbox = document.getElementById('chatbox');
    const chatPageButton = document.getElementById('chatPageButton');
    const voicePageButton = document.getElementById('voicePageButton');
    const chatPage = document.getElementById('chatPage');
    const voicePage = document.getElementById('voicePage');
    const textarea = document.querySelector("textarea")
    const settingsButton = document.getElementById('settingsButton');
    const settings = document.getElementById("settings")
    const chatContent = document.getElementById('chatContent');
    const userInput = document.getElementById('userInput');
    const sendText = document.getElementById('sendText');
    const recordButton = document.querySelector('#recordButton');
    settings.style.display="none"
    let dropdownList = document.getElementById('voices');
      dropdownList.onchange = (ev) =>{
      console.log("Selected value is: " + dropdownList.value);
    }

    let mediaRecorder;
    let recordedChunks = [];
    const btn = document.querySelector(".aiButton1");
    var sendData=document.querySelector("#sendData");
    var myTokens=document.querySelector(".tokenAmount");
    var chatPrompt=document.querySelector(".chatPrompt");
    // var myCity=document.querySelector(".userCity");

            textarea.addEventListener("keyup", e =>{
        textarea.style.height= `60`
        let scHeight = e.target.scrollHeight/2 +15;
        textarea.style.height= `${scHeight}px`

    })
    chatPageButton.addEventListener('click', async () => {
      voicePage.style.display="none"
      chatPage.style.display="block"
      console.log("chat")
    })
    settingsButton.addEventListener('click', async () => {
      if(settings.style.display=="flex"){
        console.log(settings.style.display)
        settings.style.display="none"
      }else {
        settings.style.display="flex"
      }
      console.log("settings")
    })
    voicePageButton.addEventListener('click', async () => {
      chatPage.style.display="none"
      voicePage.style.display="block"
      console.log("voice")
    })


function createMessageDiv(messageText, backgroundColor, messageType) {
    const div = document.createElement('div');
    div.style.cssText = `margin: 5px; padding: 5px; display: flex; align-items: center; display: block;width: fit-content;max-width: 400px;align-self: end;border-radius:5px;overflow-wrap: anywhere;`;

    if (messageType === 'Server') {
      div.style.cssText = `margin: 5px; padding: 5px; display: flex; align-items: center; display: block;width: fit-content;max-width: 400px;border-radius:5px;overflow-wrap: anywhere;`

    
    const span = document.createElement('span');
    span.innerText = `${messageText}`;
    span.style.cssText = "padding: 10px;background-color: #3d3d3e;;border-radius: 10px 10px 10px 0px;color: white;display:flex;"
    div.appendChild(span);

    div.id = `msg-${Date.now()}`;

    }else{

    const span = document.createElement('span');
    span.style.cssText = "padding: 10px;background-color: #72727229;border-radius: 10px 10px 0px 10px; black;display:flex;"
    span.innerText = `${messageText}`;
    div.appendChild(span);

    div.id = `msg-${Date.now()}`;
    }
    return div;
}






async function fetchAudioAfterProcessing(idToSend) {
    try {
        let response = await fetch(`/audio/${idToSend}.mp3`);
        if (response.status === 404) {
            // If not found, wait for a bit and try again
            setTimeout(() => fetchAudioAfterProcessing(idToSend), 1000);
        } else {
            const audioElement = new Audio(`/audio/${idToSend}.mp3`);
            audioElement.play();
        }
    } catch (error) {
        console.error("Error fetching the MP3:", error);
    }
}








sendText.addEventListener('click', async () => {
  let randomBoolean = true
  const message = userInput.value;
  userInput.value = '';

  const userDiv = createMessageDiv(message, '#e6e6e6', 'You');
  chatbox.appendChild(userDiv);
  
  currentResponseDiv = null;  // Reset for the new conversation turn
  
  await fetch('/chat', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ userInput: message }),
  });

  const eventSource = new EventSource('/events');
  



  eventSource.onmessage = async (event) => {

  if (event.data !== 'undefined') {
    eventSource.addEventListener('end', async () => {
      let entireResponse= ''
      let idToSend= ''
      if(randomBoolean == true){

        entireResponse = currentResponseDiv.querySelector('span').innerText
        idToSend = currentResponseDiv.id;
        console.log(entireResponse)
        console.log(idToSend)
        randomBoolean = false
        createAudioForDiv(currentResponseDiv);

        eventSource.close();
      }else{
        eventSource.close();
      }
    });
        if (!currentResponseDiv) {
            currentResponseDiv = createMessageDiv('', '#f2f2f2', 'Server');
            chatbox.appendChild(currentResponseDiv);
        }

        const span = currentResponseDiv.querySelector('span');
        span.innerText += event.data;
        chatbox.scrollTop = chatbox.scrollHeight;
    }
};

  eventSource.onerror = (error) => {
    console.error('EventSource failed:', error);
    eventSource.close();
  };
});



    sendData.addEventListener("click",()=>{
                
                var obj={
                        voice: dropdownList.value,
                        tokens:myTokens.value,
                        prompt:chatPrompt.value,
                        // city:myCity.value
                    };
                    fetch("/api",{
                    method:"POST",
                    headers:{
                        "Content-type":"application/json"
                    },
                    body:JSON.stringify(obj)
                    })
                    // .then((r)=>r.json()).then((response)=>console.log(response));
    
                })




function generateUniqueId() {
    return `${Date.now()}`;
}

                
recordButton.addEventListener('mousedown', async (event) => {
  // Start recording logic
  event.preventDefault
  recordedChunks = [];
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  mediaRecorder = new MediaRecorder(stream, {mimeType: 'audio/webm;codecs=opus'});

  mediaRecorder.ondataavailable = (e) => {
    recordedChunks.push(e.data);
    console.log(e.data)
  };

  mediaRecorder.start();

  // recordButton.disabled = true; // Optionally disable the button while recording
});

recordButton.addEventListener('mouseup', () => {
  if(!mediaRecorder){
    console.log("couldnt recieve the user voice")
  }else {
  btn.classList.add("aiButton1--loading");
  recordButton.disabled = true;
  console.log(mediaRecorder)

  mediaRecorder.onstop = async () => {
    const audioBlob = new Blob(recordedChunks, { 'type' : 'audio/webm;codecs=opus' });
    const uniqueId = generateUniqueId();

    const formData = new FormData();
    formData.append('file', audioBlob, 'recording.webm');
    formData.append('uniqueId', uniqueId);

    try {
      const response = await fetch(`/upload`, { method: 'POST', body: formData });
      const data = await response.json();
      
      setTimeout(() => {
        console.log(uniqueId)
        recordButton.classList.remove("aiButton1--loading");
        audio.src = `/audio/${uniqueId}.mp3`; 

        setTimeout(() => {
          btn.classList.remove("aiButton1--loading");
          audio.play();
        }, 100);
        document.querySelector('#playAI').disabled = false;
        recordButton.disabled = false; // Re-enable the button after recording and processing is done
      }, 1000);
    } catch (error) {
      console.error('There was an error!', error);
    }
  };

  mediaRecorder.stop();}
});



    document.querySelector('#playAI').onclick = () => {
      const audio = document.querySelector('#aiResponsePlayer'); 
      setTimeout(function wait() {
      audio.play();
    }, 1000)
    };
function createAudioForDiv(div) {
    const entireResponse = div.querySelector('span').innerText;
    const idToSend = div.id;
    
    fetch('/send-data', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
            entireResponse: entireResponse,
            divID: idToSend 
        }),
    })
    .then(response => response.json())
    .then(data => {
      if (data.status === 'Audio created successfully.') {
    // Create the elements
    const audio = document.createElement('audio');
    const audioSrc = `/audio/${div.id}.mp3`;
    audio.src = audioSrc;
    div2 = document.createElement('div')
    div2.style.cssText = "display: flex;flex-wrap: nowrap;align-items: center;margin-top: 4px;width: fit-content;background-color: #7272724f;border-radius: 10px 10px 10px 0px;"
    const playPauseBtn = document.createElement('button');
    playPauseBtn.innerText = '▶';
    playPauseBtn.style.cssText = "    margin-left: 5px;border-radius: 20px;width: 40px;height: 40px;"
    const canvas = document.createElement('canvas');
    canvas.style.cssText = "padding: 10px;;border-radius: 10px 10px 10px 0px;color: white;"
    div2.appendChild(audio);
    div2.appendChild(playPauseBtn);
    let progressOverlay;

    const ctx = canvas.getContext('2d');
    
    let audioBuffer;
    let audioData;
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    fetch(audioSrc)
        .then(response => response.arrayBuffer())
        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
        .then(buffer => {
            audioBuffer = buffer;
            audioData = buffer.getChannelData(0);
            drawWaveform();
        });
    

        // const numOfBars = 40;
        const numOfBars = 100; 

        function drawWaveform() {
          const numOfBars = 100;  // set number of bars you'd like to display
          const spacing = 2;  // width of spacing in px
          const samplesPerBar = Math.ceil(audioData.length / numOfBars);

          const totalSpacing = (numOfBars - 1) * spacing;  // total width of all spacings
          const availableWidth = canvas.width - totalSpacing;  // remaining width after all spacings
          const barWidth = availableWidth / numOfBars;  // width of each bar
          const ampScale = canvas.height / 2;

          for (let i = 0; i < numOfBars; i++) {
              let min = 1.0;
              let max = -1.0;

              for (let j = 0; j < samplesPerBar; j++) {
                  const datum = audioData[(i * samplesPerBar) + j];
                  if (datum < min) min = datum;
                  if (datum > max) max = datum;
              }

              ctx.fillStyle = '#4a4a4a';  // Color for waveform
              // The position is adjusted by adding the spacing (i * spacing) to it.
              ctx.fillRect((i * barWidth) + (i * spacing), (1 + min) * ampScale, barWidth, Math.max(1, (max - min) * ampScale));
          }
                 const containerDiv = document.createElement('div');
    containerDiv.style.position = 'relative'; // Required for correct overlay positioning

    // Convert the canvas drawing to an image
    const waveformImage = document.createElement('img');
    waveformImage.src = canvas.toDataURL("image/png");
    waveformImage.style.width = '250px'; 
    waveformImage.style.height = '60px';
    waveformImage.classList.add('waveformImage'); // Use class instead of ID for multiple elements

    // Create a progress overlay div
    progressOverlay = document.createElement('div');
    progressOverlay.style.position = 'absolute';
    progressOverlay.style.top = '0';
    progressOverlay.style.left = '0';
    progressOverlay.style.height = '100%';
    progressOverlay.style.width = '0%';
    progressOverlay.style.backgroundColor = '#c9ced3c4';
    progressOverlay.style.pointerEvents = 'none';
    progressOverlay.style.borderRadius = '10px';
    progressOverlay.classList.add('progressOverlay');

    // Append the waveform and progress overlay to the container



    containerDiv.appendChild(waveformImage); // if you want to go back //above js and change the appendchild to canvas
    containerDiv.appendChild(progressOverlay);
    div2.appendChild(containerDiv);
    div.appendChild(div2)

    waveformImage.addEventListener('click', function(event) {
        const rect = waveformImage.getBoundingClientRect();
        const scaleX = waveformImage.width / rect.width;

        // Calculate the exact position of the click relative to the image
        const clickPosition = (event.clientX - rect.left) * scaleX; 

        const clickPercentage = clickPosition / waveformImage.width;
        audio.currentTime = clickPercentage * audio.duration;
        console.log("Click Position:", clickPosition);
        console.log("Click Percentage:", clickPercentage);
        console.log("Audio Current Time:", audio.currentTime);

        updatePlaybackProgressForMessage(progressOverlay, audio);
    });
        }


    
    playPauseBtn.addEventListener('click', function() {
        if (audio.paused) {
            audio.play();
            playPauseBtn.innerText = '||';
            updatePlaybackProgressForMessage(progressOverlay, audio);
        } else {
            audio.pause();
            playPauseBtn.innerText = '▶';
        }
    });


function togglePlayPause() {
    if (audio.paused) {
        audio.play();
        playPauseBtn.innerText = '||';
        updatePlaybackProgress();
    } else {
        audio.pause();
        playPauseBtn.innerText = '▶';
    }
}

    audio.addEventListener('ended', function() {
    playPauseBtn.innerText = '▶';
    });

function updatePlaybackProgressForMessage(progressOverlay, audio) {
    if (audio.currentTime < audio.duration) {
        const percentage = (audio.currentTime / audio.duration) * 100;

        // Update the width of the specific progress overlay
        progressOverlay.style.width = percentage + '%';

        requestAnimationFrame(() => updatePlaybackProgressForMessage(progressOverlay, audio));
    }
}
}

    })
    .catch(error => {
        console.error('There was an error posting the message:', error);
    });
}
  </script>
</body>
